## 文件系统

![image-20220902143223702](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220902143223702.png)

- open函数
  - 可以打开文件，如果没有可以创建
    - 创建时需要加上creat参数（宏定义间使用|分隔），且填写第三个参数mode_t
    - ![image-20220913153335791](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220913153335791.png)
    - 创建的文件受umask影响。=mode&~umask
  - 返回一个int值fd（文件描述符），如果失败返回-1，并给errno赋值
  - mode_t mode参数用于创建文件
  - ![image-20220913153724379](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220913153724379.png)
- errno变量
  - 使用errno.h
  - 大多数系统函数若错误都会给errno赋值
  - errno是一个int，可以使用strerrror(errno)将其转换为具体的原因
- argc 参数数量，永远大于0和1
- argv 参数数组，0存放程序的名称，所以1才是传参
- read函数
  - 输入
    - fd，文件描述符
    - buf 存数据的缓冲区
    - count 缓冲区大小
  - 输出
    - 成功读到的字节数
    - 为0证明读完了
    - 
    - 失败返回-1
- write函数
  - 输入
    - fd，文件描述符
    - buf 存数据的缓冲区
    - count 需要写入的数据大小
  - 输出
    - 成功写入的字节数
    - 0就是啥都没写
    - 失败返回-1
- 实现文件CP的程序
  - ![image-20220917150045590](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220917150045590.png)
  - perror("open argv1 error")
    - 其会输出包含errno提示的错误信息，结合了strerrror
    - ![image-20220917150531294](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220917150531294.png)
  - ![image-20220917150631060](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220917150631060.png)
- 与fopen，fgetc，fputc的区别
  - ![image-20220917151529287](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220917151529287.png)
  - 使用strace追踪程序运行情况
    - strace ./xxx
  - ![image-20220917152051718](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220917152051718.png)
    - 从用户层到内核层所需要的时间较长（如write一次时间比较长）
    - 而fputc内置一个缓冲区，缓存后一次性write
    - 内核层也有一个缓冲，内核择机将数据写入物理磁盘
    - 蓝色的缓冲区叫用户级缓冲区
    - 所有的缓冲区都遵循一个预读入缓输出的原则。读多点，等多点再写
    - 因此直接用系统函数并不比先用库函数（让库函数调用系统函数）快
    - **能用库函数不要用系统函数，但是如果有摒弃缓冲区等需求还是可以用的**
    - 
