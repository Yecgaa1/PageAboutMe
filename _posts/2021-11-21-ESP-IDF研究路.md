---
layout: post
title: ESP-IDF研究路
categories: 日志
tags: 
    - 日志 
    - 大二
BGImage: 'https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/20220310123346.png'
jekyll-theme-WuK:
    musicid: '34367899'
---

### 环境：虚拟机Ubuntu20

框架：IDF

工具使用上，原来想用PlatformIO直接解决，但是发现每次整理编译链太慢



# 环境安装的方案

其实直接用vscode里面让他自己安装最好



先按照github安装IDF框架（使用sh命令行）

然后安装vscode的插件，设置以下内容

```
${env:HOME}/esp/esp-idf
```

![image-20211126215922303](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20211126215922303.png)

![image-20211126220012275](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20211126220012275.png)

```
/home/xtx/.espressif/python_env/idf5.0_py3.8_env/bin/python
```

每一个python虚拟环境都有一个python.exe，可以先看看export.sh的设置然后which一下

![image-20211126220126340](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20211126220126340.png)

```
${env:HOME}/esp/esp-idf/tools
```

[issuse](https://github.com/espressif/vscode-esp-idf-extension/issues/580)

# 初始化各种外设

## wifi

sta：站点模式，就是作为设备接入wifi

AP：接入点模式，就是自己开wifi

先是netIf框架(底层 TCP/IP 堆栈)

```c++
    ESP_ERROR_CHECK(esp_netif_init());

    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();//初始化默认netif为sta模式
```

esp_event_loop_create_default参见事件循环库

简单描述就是打开一个循环处理接入wifi这些事件

这里创建默认循环（默认命名和处理频率而已），循环里面默认没有任何东西！！！

需要在后面的代码中再向循环中添加事件及其事件的处理方法



然后是初始化wifi外设（并没有指定是啥模式，就相当于打开时钟）

```c++
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  ESP_ERROR_CHECK(esp_wifi_init(&cfg));
```



然后是上文提到的事件注册

```c++
    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                                                        ESP_EVENT_ANY_ID,
                                                        &event_handler,
                                                        NULL,
                                                        &instance_any_id));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,
                                                        IP_EVENT_STA_GOT_IP,
                                                        &event_handler,
                                                        NULL,
                                                        &instance_got_ip));
```

[esp_event_handler_instance_register](https://docs.espressif.com/projects/esp-idf/en/latest/esp32s2/api-reference/system/esp_event.html#_CPPv435esp_event_handler_instance_register16esp_event_base_t7int32_t19esp_event_handler_tPvP28esp_event_handler_instance_t)将事件处理程序的实例注册到默认循环

# 函数用法

## ESP相关

### ESP_ERROR_CHECK

如果不是ESP_OK自动重启

### ESP_LOGI

```cpp
ESP_LOGI(TAG, "ESP_WIFI_MODE_STA");
```

日志记录器，可以打印到串口，但很明显比printf优雅

![image-20211122224342495](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20211122224342495.png)







# 以下是正式开始学的内容

## 点灯

blink是点灯的意思，别老想到点灯科技

```
/* Use project configuration menu (idf.py menuconfig) to choose the GPIO to blink,
   or you can edit the following line and set a number here.
*/

#define BLINK_GPIO CONFIG_BLINK_GPIO
```

这里的意思是点灯的GPIO可以用idf.py menuconfig配置，事实证明确实如此



## Http客户端

大跃进

http的方案好像有两种，例子都可以在如下文件夹找到

```
protocols/esp_http_client/main/esp_http_client_example.c
```

一种是：static void http_rest_with_url(void)，但是测试过好像不太行（它的示例可以跑，但是跑我自己的post就爆栈重启）

另一种是：

```c++
static void http_rest_with_hostname_path(void)
```

测试过是有效的



wifi连接在示例里面是用一套很方便但不够安全（）的方案做的

```
ESP_ERROR_CHECK(example_connect());
ESP_LOGI(TAG, "Connected to AP, begin http example");

```

就这么简单？！wifi密码是在menuconfig配置的

**### About the** **`example_connect()`** **Function**



Protocols examples use a simple helper function, `example_connect()`, to establish Wi-Fi and/or Ethernet connection. This function is implemented in [examples/common_components/protocol_examples/common/connect.c](../common_components/protocol_examples_common/connect.c), and has a very simple behavior: block until connection is established and IP address is obtained, then return. This function is used to reduce the amount of boilerplate and to keep the example code focused on the protocol or library being demonstrated.



The simple `example_connect()` function does not handle timeouts, does not gracefully handle various error conditions, and is only suited for use in examples. When developing real applications, this helper function needs to be replaced with full Wi-Fi / Ethernet connection handling code. Such code can be found in [examples/wifi/getting_started/](../wifi/getting_started) and [examples/ethernet/basic/](../ethernet/basic) examples.

大概意思就是解释这样做不够安全（线程上）



```c++
esp_err_t _http_event_handler(esp_http_client_event_t *evt)
```

作为http事件处理函数

记得freertos的任务需要一直while(1)







### x-www-form-urlencoded与json的区别

结论就是：post报文的格式是不一样的

https://blog.csdn.net/qq_23049221/article/details/108621301

### x-www-form-urlencoded

application/x-www-from-urlencoded:这是默认的编码格式,它是以传输键值对的形式传参的
例如:name=张三&age=18

### json

application/json:他传输的是json格式的数据
例如{“name”:“张三”,“age”:“18”}



## 对于post接不到数据

只用http流是没问题的

例程可见日历的git



### No server verification option set in esp_tls_cfg_t structure

![image-20220515183424063](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220515183424063.png)



