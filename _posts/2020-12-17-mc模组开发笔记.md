## idea乱码

在help里进VM参数设置

https://www.huaweicloud.com/articles/9096546b90dc8c52d52138d01875b8ed.html

## ->与Lambda 表达式

```
tileEntityType ->
```

https://www.runoob.com/java/java8-lambda-expressions.html

简单说就是return后面一坨给前面，后面一坨可以是函数表达式

## 方块注册逻辑分析



## 事件类型分析

![image-20201220020426110](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20201220020426110.png)

有很详细的描述

```
LivingDeathEvent is fired when an Entity dies. 
This event is fired whenever an Entity dies in EntityLivingBase.onDeath(DamageSource), EntityPlayer.onDeath(DamageSource), and EntityPlayerMP.onDeath(DamageSource).  
This event is fired via the ForgeHooks.onLivingDeath(EntityLivingBase, DamageSource).

source contains the DamageSource that caused the entity to die.

This event is Cancelable. 
If this event is canceled, the Entity does not die.

This event does not have a result. net.minecraftforge.eventbus.api.Event.HasResult

This event is fired on the MinecraftForge.EVENT_BUS.
```



## 发送对话给玩家

1. 


```java
import net.minecraft.entity.Entity;

Entity entity=event.getEntity();
String message="Hello world";
StringTextComponent text=new StringTextComponent(message);
entity.sendMessage(text,entity.getUniqueID());
```

2. 


```java
import net.minecraft.entity.player.PlayerEntity;
PlayerEntity playerEntity= (PlayerEntity) entity;
playerEntity.sendMessage(new StringTextComponent("菜鸟<"+playerEntity.getName().getString()+">上线了~"),playerEntity.getUniqueID());
            
```

3. 

```java
player.sendMessage(ITextComponent.getTextComponentOrEmpty("Good!"),player.getUniqueID());//PlayerEntity下的getUniqueID
//使用ITextComponent.getTextComponentOrEmpty直接转换string
```


记得先确认该代码不在服务器端运行

```java
if (!event.getWorld().isRemote)
    
```

同时在调试时修改player.sendMessage然后重载是可以生效的

## forge事件注册

```java
@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE)//关键关键
public class Join {
    
    
    @SubscribeEvent
    public static void onPlayerJoin(EntityJoinWorldEvent event)//EntityJoinWorldEvent 关键，和onPlayerJoin类名无关
    {
        
    }
```



## 注册一个新的方块属性

```java
private static final IntegerProperty state=IntegerProperty.create("count",0,1);//必须是private static

@Override
    protected void fillStateContainer(StateContainer.Builder<Block, BlockState> builder) {
        builder.add(state);
        super.fillStateContainer(builder);
}
```

然后在构造函数中可以加入这段来默认属性

```java
this.setDefaultState(this.stateContainer.getBaseState().with(state,0));
```

## 多属性方块的贴图

注意点：

方块贴图没啥问题，对应物品的贴图的json文件直接起和setRegistryName一样的名字

## 判断是不是在服务器执行

worldIn.isRemote 返回true在客户端执行

false在服务端执行

## 有价值的包 

net.minecraft.block.properties

## 实现或重写快捷键

Ctrl+O

## 重载和重写

https://www.runoob.com/java/java-override-overload.html





## 以下内容针对MC1.18.1 Forge版本跟随

由于函数库的大变动，所以在这里写写

![S1EQwrm.png](https://i.imgur.com/S1EQwrm.png)

level是世界维度或者服务器

Blockpos是坐标，一般是xyz构造

Block是方块（哪种），BlockState是世界里的方块（哪个）

可以通过level获取state和entity



### 导入外部jar库的方案在1.17后有所改动

关键：

```
configurations {
    library
    implementation.extendsFrom library
}
minecraft.runs.all {
    lazyToken('minecraft_classpath') {
        configurations.library.copyRecursive().resolve().collect { it.absolutePath }.join(File.pathSeparator)
    }
}
```

与

```
library files("libs/luaj-jse-3.0.2.jar")//在dependencies里
```

而不是implementation



全貌

```java
// Fix non-mod dependencies not being loaded in dev
configurations {
    library
    implementation.extendsFrom library
}
minecraft.runs.all {
    lazyToken('minecraft_classpath') {
        configurations.library.copyRecursive().resolve().collect { it.absolutePath }.join(File.pathSeparator)
    }
}


dependencies {
    // Specify the version of Minecraft to use. If this is any group other than 'net.minecraft', it is assumed
    // that the dep is a ForgeGradle 'patcher' dependency, and its patches will be applied.
    // The userdev artifact is a special name and will get all sorts of transformations applied to it.
    minecraft 'net.minecraftforge:forge:1.18.1-39.0.64'
    library files("libs/luaj-jse-3.0.2.jar")
//    compileOnly fg.deobf("mezz.jei:jei-${jei_version}:api")
//    implementation fg.deobf("mezz.jei:jei-${jei_version}")
//
//
    compileOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}:api")
    // at runtime, use the full JEI jar
    runtimeOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}")
    implementation fg.deobf("curse.maven:the-one-probe-245211:3550084")

    // Real mod deobf dependency examples - these get remapped to your current mappings
    // compileOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}:api") // Adds JEI API as a compile dependency
    // runtimeOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}") // Adds the full JEI mod as a runtime dependency
    // implementation fg.deobf("com.tterrag.registrate:Registrate:MC${mc_version}-${registrate_version}") // Adds registrate as a dependency

    // Examples using mod jars from ./libs

    // For more info...
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html
}
```

### 方块点击是重写use方法

```java
public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult trace) {
        if (!level.isClientSide) {
            System.out.println("Hello From code1!");
            BlockState a=level.getBlockState(pos);
        }
    return InteractionResult.SUCCESS;
}
```

### 方块最基本的属性，blockstate属性

```java
BlockState a=level.getBlockState(pos);
```

通过pos（xyz）坐标配合方法得出BlockState对象，而不是直接构造函数

世界是level，可以通过玩家获取，或者use函数自带

### Blockentity方块实体属性

也可以通过level得到

```
BlockEntity getBlockEntity
```

### 找一个方法

首先定位到它的类型，比如定位到Blockentity，然后想要查看它的得到方法

![image-20220212010404876](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220212010404876.png)

中键，然后右上角选择在查找框打开

![image-20220212010538715](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220212010538715.png)

按照返回值类型查找

![image-20220212010650533](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220212010650533.png)

按照逻辑找到得到方法

![image-20220212010811736](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220212010811736.png)

如果找到了接口要找实现，不应该对方法中键，应该在右边找到图标搜索实现

![image-20220212010911383](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220212010911383.png)





### 获取player方案

1.UUID获取

2.通过玩家主动交互获取



### 获取level方案

1.通过player获取

